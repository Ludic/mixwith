{"version":3,"sources":["webpack:///webpack/bootstrap 86b139488a629d966521","webpack:///./src/mixwith.js"],"names":["_appliedMixin","apply","superclass","mixin","application","prototype","unwrap","isApplicationOf","proto","hasOwnProperty","hasMixin","o","Object","getPrototypeOf","_wrappedMixin","wrap","wrapper","setPrototypeOf","_cachedApplications","Cached","cachedApplications","Map","get","set","DeDupe","HasInstance","Symbol","hasInstance","defineProperty","value","BareMixin","s","Mixin","SymbolName","for","SymbolValue","Interface","name","enumerable","check","symbol","undefined","mix","MixinBuilder","mixins","reduce","_reduce","c","m","ret"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 86b139488a629d966521","'use strict';\n\n// used by apply() and isApplicationOf()\nconst _appliedMixin = '__mixwith_appliedMixin';\n\n/**\n * A function that returns a subclass of its argument.\n *\n * @example\n * const M = (superclass) => class extends superclass {\n *   getMessage() {\n *     return \"Hello\";\n *   }\n * }\n *\n * @typedef {Function} MixinFunction\n * @param {Function} superclass\n * @return {Function} A subclass of `superclass`\n */\n\n/**\n * Applies `mixin` to `superclass`.\n *\n * `apply` stores a reference from the mixin application to the unwrapped mixin\n * to make `isApplicationOf` and `hasMixin` work.\n *\n * This function is usefull for mixin wrappers that want to automatically enable\n * {@link hasMixin} support.\n *\n * @example\n * const Applier = (mixin) => wrap(mixin, (superclass) => apply(superclass, mixin));\n *\n * // M now works with `hasMixin` and `isApplicationOf`\n * const M = Applier((superclass) => class extends superclass {});\n *\n * class C extends M(Object) {}\n * let i = new C();\n * hasMixin(i, M); // true\n *\n * @function\n * @param {Function} superclass A class or constructor function\n * @param {MixinFunction} mixin The mixin to apply\n * @return {Function} A subclass of `superclass` produced by `mixin`\n */\nexport const apply = (superclass, mixin) => {\n  let application = mixin(superclass);\n  application.prototype[_appliedMixin] = unwrap(mixin);\n  return application;\n};\n\n/**\n * Returns `true` iff `proto` is a prototype created by the application of\n * `mixin` to a superclass.\n *\n * `isApplicationOf` works by checking that `proto` has a reference to `mixin`\n * as created by `apply`.\n *\n * @function\n * @param {Object} proto A prototype object created by {@link apply}.\n * @param {MixinFunction} mixin A mixin function used with {@link apply}.\n * @return {boolean} whether `proto` is a prototype created by the application of\n * `mixin` to a superclass\n */\nexport const isApplicationOf = (proto, mixin) =>\n  proto.hasOwnProperty(_appliedMixin) && proto[_appliedMixin] === unwrap(mixin);\n\n/**\n * Returns `true` iff `o` has an application of `mixin` on its prototype\n * chain.\n *\n * @function\n * @param {Object} o An object\n * @param {MixinFunction} mixin A mixin applied with {@link apply}\n * @return {boolean} whether `o` has an application of `mixin` on its prototype\n * chain\n */\nexport const hasMixin = (o, mixin) => {\n  while (o != null) {\n    if (isApplicationOf(o, mixin)) return true;\n    o = Object.getPrototypeOf(o);\n  }\n  return false;\n}\n\n\n// used by wrap() and unwrap()\nconst _wrappedMixin = '__mixwith_wrappedMixin';\n\n/**\n * Sets up the function `mixin` to be wrapped by the function `wrapper`, while\n * allowing properties on `mixin` to be available via `wrapper`, and allowing\n * `wrapper` to be unwrapped to get to the original function.\n *\n * `wrap` does two things:\n *   1. Sets the prototype of `mixin` to `wrapper` so that properties set on\n *      `mixin` inherited by `wrapper`.\n *   2. Sets a special property on `mixin` that points back to `mixin` so that\n *      it can be retreived from `wrapper`\n *\n * @function\n * @param {MixinFunction} mixin A mixin function\n * @param {MixinFunction} wrapper A function that wraps {@link mixin}\n * @return {MixinFunction} `wrapper`\n */\nexport const wrap = (mixin, wrapper) => {\n  Object.setPrototypeOf(wrapper, mixin);\n  if (!mixin[_wrappedMixin]) {\n    mixin[_wrappedMixin] = mixin;\n  }\n  return wrapper;\n};\n\n/**\n * Unwraps the function `wrapper` to return the original function wrapped by\n * one or more calls to `wrap`. Returns `wrapper` if it's not a wrapped\n * function.\n *\n * @function\n * @param {MixinFunction} wrapper A wrapped mixin produced by {@link wrap}\n * @return {MixinFunction} The originally wrapped mixin\n */\nexport const unwrap = (wrapper) => wrapper[_wrappedMixin] || wrapper;\n\nconst _cachedApplications = '__mixwith_cachedApplications';\n\n/**\n * Decorates `mixin` so that it caches its applications. When applied multiple\n * times to the same superclass, `mixin` will only create one subclass, memoize\n * it and return it for each application.\n *\n * Note: If `mixin` somehow stores properties its classes constructor (static\n * properties), or on its classes prototype, it will be shared across all\n * applications of `mixin` to a super class. It's reccomended that `mixin` only\n * access instance state.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to wrap with caching behavior\n * @return {MixinFunction} a new mixin function\n */\nexport const Cached = (mixin) => wrap(mixin, (superclass) => {\n  // Get or create a symbol used to look up a previous application of mixin\n  // to the class. This symbol is unique per mixin definition, so a class will have N\n  // applicationRefs if it has had N mixins applied to it. A mixin will have\n  // exactly one _cachedApplicationRef used to store its applications.\n\n  let cachedApplications = superclass[_cachedApplications];\n  if (!cachedApplications) {\n    cachedApplications = superclass[_cachedApplications] = new Map();\n  }\n\n  let application = cachedApplications.get(mixin);\n  if (!application) {\n    application = mixin(superclass);\n    cachedApplications.set(mixin, application);\n  }\n\n  return application;\n});\n\n/**\n * Decorates `mixin` so that it only applies if it's not already on the\n * prototype chain.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to wrap with deduplication behavior\n * @return {MixinFunction} a new mixin function\n */\nexport const DeDupe = (mixin) => wrap(mixin, (superclass) =>\n    (hasMixin(superclass.prototype, mixin))\n      ? superclass\n      : mixin(superclass));\n\n/**\n * Adds [Symbol.hasInstance] (ES2015 custom instanceof support) to `mixin`.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to add [Symbol.hasInstance] to\n * @return {MixinFunction} the given mixin function\n */\nexport const HasInstance = (mixin) => {\n  if (Symbol && Symbol.hasInstance && !mixin[Symbol.hasInstance]) {\n    Object.defineProperty(mixin, Symbol.hasInstance, {\n      value(o) {\n        return hasMixin(o, mixin);\n      },\n    });\n  }\n  return mixin;\n};\n\n/**\n * A basic mixin decorator that applies the mixin with {@link apply} so that it\n * can be used with {@link isApplicationOf}, {@link hasMixin} and the other\n * mixin decorator functions.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to wrap\n * @return {MixinFunction} a new mixin function\n */\nexport const BareMixin = (mixin) => wrap(mixin, (s) => apply(s, mixin));\n\n/**\n * Decorates a mixin function to add deduplication, application caching and\n * instanceof support.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to wrap\n * @return {MixinFunction} a new mixin function\n */\nexport const Mixin = (mixin) => DeDupe(Cached(BareMixin(mixin)));\n\nconst SymbolName = Symbol.for('_Symbol_name_')\nconst SymbolValue = Symbol.for('_Symbol_value_')\n/**\n * Decorates a mixin function to add deduplication, application caching and\n * instanceof support.\n *\n * @function\n * @param {MixinFunction} mixin The mixin to wrap\n * @return {MixinFunction} a new mixin function\n */\nexport const Interface = (name, mixin, value = true) => {\n  if(Symbol && Symbol.for){\n    mixin[SymbolName] = name;\n    mixin[SymbolValue] = value;\n    // mixin.prototype.is = value\n  }\n  return Mixin(mixin);\n}\n\n// helper method for checking Interface implementation\n\nObject.defineProperty(Object.prototype, 'implements', {\n  enumerable: false,\n  value: function(check){\n    let symbol = false;\n\n    switch(typeof check){\n      case 'string':\n        symbol = Symbol.for(check);\n        break;\n      case 'symbol':\n        symbol = check;\n        break;\n      default:\n        if(check[SymbolName] != null){\n          symbol = Symbol.for(check[SymbolName])\n        }\n    }\n\n    return symbol ? this[symbol] != undefined : false;\n  },\n})\n\n/**\n * A fluent interface to apply a list of mixins to a superclass.\n *\n * ```javascript\n * class X extends mix(Object).with(A, B, C) {}\n * ```\n *\n * The mixins are applied in order to the superclass, so the prototype chain\n * will be: X->C'->B'->A'->Object.\n *\n * This is purely a convenience function. The above example is equivalent to:\n *\n * ```javascript\n * class X extends C(B(A(Object))) {}\n * ```\n *\n * @function\n * @param {Function} [superclass=Object]\n * @return {MixinBuilder}\n */\nexport const mix = (superclass) => new MixinBuilder(superclass);\n\nclass MixinBuilder {\n\n  constructor(superclass = class {}) {\n    this.superclass = superclass;\n  }\n\n  /**\n   * Applies `mixins` in order to the superclass given to `mix()`.\n   *\n   * @param {Array.<Mixin>} mixins\n   * @return {Function} a subclass of `superclass` with `mixins` applied\n   */\n  with(...mixins) {\n    return mixins.reduce(this._reduce, this.superclass);\n  }\n\n  _reduce(c,m){\n    let ret = m(c);\n    ret.prototype[Symbol.for(m[SymbolName])] = m[SymbolValue];\n    return ret;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mixwith.js"],"sourceRoot":""}